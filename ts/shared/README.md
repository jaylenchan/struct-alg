## 对数器

1. 按照功能实现一个方法 A（待测试）
2. 按照功能实现一个方法 B（但是 B 方法容易实现并且复杂度没那么好）
3. 实现一个随机样本产生器
4. 用同样的随机样本来跑方法 A 和方法 B，观察结果是否一致
5. 如果有一个样本使得比对出错，打印样本分析是哪个方法出错
6. 当样本量足够大且比对依然正确的时候，可以判定方法 A 已经实现正确

## 比较器

1. 比较器用于自定义排序规则，本身就是一条策略，告诉结构如何去排序 a，b 两个东西，其形式是：`const comparator = (a,b) => a-b`
2. 比较器的规则统一如下：
   - 如果比较后，返回负数，则 a 在前面
   - 如果比较后，返回正数，则 b 在前面
   - 如果比较后，返回 0，则无所谓
3. 升序排列逻辑理解：`a-b`，当结果为负数，说明 a 比 b 小，小数是 a，又因为负数 a 排前面，所以小数排前面，于是排序完后是升序
4. 降序排列逻辑理解：`b-a`, 当结果为负数，说明 b 比 a 小，大数是 a，又因为负数 a 排前面，所以大数排前面，于是排序完后是降序
5. 应用：大根堆和小根堆，我们可以通过比较器来实现。输入比较器后`(a,b) => a-b`，那么我们可以认为，`a-b`是负数的话，说明 a 是小数，又因为负数让 a 往上靠，因此我们让小数靠顶端，于是经过建设后，数小的都在顶端，所以成为了小根堆。如果我们改下比较器`(a,b) => b-a`，那么我们认为,`b-a`是负数的话，大数是 a，又因为我们说负数就让 a 排上，所以大数都往顶端靠，因此建设出了大根堆。
