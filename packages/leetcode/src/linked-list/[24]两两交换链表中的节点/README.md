# 思路

1. 由于经过特判，所以链表至少有两个节点。
2. 对这两个节点先进行一次反转，获得反转后区间的头部和尾部，以及下一次反转的起始点
3. 循环判断下一次反转的起始点是否存在，存在的话按照如下操作：
1 以下一次反转起点作为起始点，进行链表的两两反转操作
2 将上一次反转的tail的next指向这一次反转的区间的头部newHead(因为链表在反转的时候，我的操作是直接断开，成为单独一个链表小段)
3 更新下一次反转的起始点oldNext为这一次反转后获得的nextOldNext
4 更新新的tail在哪里，tail = nextTail，就是将上次的tail跳到这一次反转的tail处，以便下一次的时候需要他做过程2操作
4. 循环结束，返回整个链表的头节点
