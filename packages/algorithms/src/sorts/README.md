# 排序算法

## 选择排序

- 算法步骤
  首先,找到数组中最小的那个元素,其次,将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。再次,在剩下的元素中找到最小的元素,将它与数组的第二个元素交换位置。如此往复,直到将整个数组排序

## 插入排序

- 算法步骤
  从第二个元素开始遍历整个数组，以每次遍历到的索引作为结尾，不断从这个结尾开始往左边一一比较数字，如果乱序就交换两个数字。
直到整个数组遍历完成，结束排序过程

## 归并排序

整体是递归算法，左边排序+右边排序+merge 让整体有序的过程。让其整体有序的过程用了排外序的方法，利用 master 公式来求解时间复杂度

- 算法步骤
  将给定数组分成左右两部分
  对左边部分进行排序，对右边部分进行排序
  经过以上步骤，左右部分排序完成，使用一个等长的辅助数组进行合并操作：
  - 左部分的左边界是 l，右边界是 mid；右部分的左边界是 mid+1，右边界是 r
  - 从 l | mid+1 开始，左部分和右边分的左指针开始往右跑，不断比较左部分和右边分的左指针指向的元素大小，谁大往辅助数组里填，直到跑完左部分或者右部分，停止操作
  - 判断左部分还是右部分有剩余的元素，将剩余的没跑完的元素往辅助数组里填
  - 结束合并过程

## 快速排序

- 算法步骤：partition(三分)
  将数组中小于 pivot 放左，等于 pivot 放中间，大于 pivot 放右边
  设置两个边界：less，more
  less：是小于区域边界 ：往右边扩 : less = left - 1 开始
  more：是大于区域边界：往左边扩 : right = nums.length - 1 开始
  从 i=left 开始遍历数组
  - 分类讨论：
    - nums[i] = pivot : 什么也不做，i++
    - nums[i] < pivot: 将当前 nums[i]和 less 区域的右一个数做交换，然后 less++扩大 less 区域，i++
    - nums[i] > pivot: 将当前 nums[i]和 more 区域的左一个数做交换，然后 more--扩大 more 区域，i 继续留原地不动，继续看 nums[i]
  当 i 和 more 撞上的时候，停止遍历

- 三路实质
  i 来到当前位置，i 左侧是小于区域，i 右侧有一堆没看的数和大于区域
  实际上就是当前 i 的元素是等于区域的，只需要扩大等于区域就好，i 直接++，代码上就是啥没干直接++
  如果是 nums[i]是小于区域的数，那么就发送这个数到小于区域，推着等于区域往右走
  实际上推的动作就是交换等于区域的第一个数，根当前 i 所在位置交换，然后扩大小于区域
  如果是 nums[i]是大于区域的数，那么就把这个数发送到大于区域，，然后大于区域推着往左走
  实际上推的动作是交换当前 i 的元素和大于区域的左边一个位置，然后大于区域扩大
  但是因为换过来的数没看过，所以 i 不能动，需要再次查看这个数的情况
